import os
import json
import shutil
import tempfile
import unittest

from k2spicedb import cli
from k2spicedb.keycloak_parser import KeycloakParser
from k2spicedb.schema_generator import SchemaGenerator

# Disable logging
import logging
logging.disable(logging.CRITICAL)

class TestCLI(unittest.TestCase):
    def setUp(self):
        # Create a temporary directory for input/output files
        self.tempdir = tempfile.mkdtemp()
        # Define a simple realm JSON for testing
        self.test_realm_data = {
            "realm": "CLITestRealm",
            "roles": {
                "realm": [
                    {"name": "roleA", "composite": False}
                ],
                "client": {
                    "proj": [
                        {"name": "roleB", "composite": False}
                    ]
                }
            },
            "groups": [
                {"name": "grp", "subGroups": []}
            ]
        }
        # Write this to a file in tempdir
        self.input_file = os.path.join(self.tempdir, "realm.json")
        with open(self.input_file, 'w', encoding='utf-8') as f:
            json.dump(self.test_realm_data, f)
    
    def tearDown(self):
        # Remove temporary directory
        shutil.rmtree(self.tempdir)

    def test_cli_single_no_llm(self):
        # Output file path in tempdir
        out_file = os.path.join(self.tempdir, "output.zed")
        # Run CLI main for a single input with no-llm
        ret_code = cli.main([self.input_file, "--no-llm", "-o", out_file])
        self.assertEqual(ret_code, 0)
        # The output file should be created
        self.assertTrue(os.path.exists(out_file))
        # Its content should match the schema generated by SchemaGenerator for the same realm
        parser = KeycloakParser()
        realm = parser.parse_file(self.input_file)
        expected_schema = SchemaGenerator.generate_schema(realm)
        with open(out_file, 'r', encoding='utf-8') as f:
            actual_schema = f.read()
        self.assertEqual(actual_schema.strip(), expected_schema.strip())

    def test_cli_multiple_no_llm(self):
        # Create a second input file
        second_realm_data = {
            "realm": "SecondRealm",
            "roles": {"realm": [], "client": {}},
            "groups": []
        }
        input_file2 = os.path.join(self.tempdir, "realm2.json")
        with open(input_file2, 'w', encoding='utf-8') as f:
            json.dump(second_realm_data, f)
        # Use the directory as input and a new output directory
        output_dir = os.path.join(self.tempdir, "outdir")
        os.makedirs(output_dir)
        ret_code = cli.main([self.tempdir, "--no-llm", "-o", output_dir, "-j", "2"])
        self.assertEqual(ret_code, 0)

        print("DEBUG: Parsed realm2.json")
        with open(input_file2, 'r', encoding='utf-8') as f:
            print(json.load(f))  # Print the parsed input
        
        # Check that output files for both inputs exist
        out1 = os.path.join(output_dir, "realm.zed")
        out2 = os.path.join(output_dir, "realm2.zed")
        self.assertTrue(os.path.exists(out1))
        self.assertTrue(os.path.exists(out2))
        # Verify basic content in each output (e.g., the realm name appears as comment or definition context)
        with open(out1, 'r') as f1, open(out2, 'r') as f2:
            content1 = f1.read()
            content2 = f2.read()
        self.assertIn("roleA", content1)
        self.assertIn("roleB", content1)
        self.assertIn("SecondRealm", content2)  # likely as realm name or no content if empty, check at least file not empty
        # Both output files should contain at least the user definition
        self.assertIn("definition user", content1)
        self.assertIn("definition user", content2)
